# 设计模式概述



设计模式的正式提出：

在1995年，四位工程师 艾瑞克·伽马、理查德·海尔姆、拉尔夫·约翰森、约翰·威利斯迪斯共同出版了《设计模式：可复用面向对象软件基础》，这本书收录了23种设计模式，让设计模式更为广泛的传播与使用



设计模式的本质：

>  软件设计模式就是被反复使用的、代码设计经验的总结。它具有一定的普遍性、可以被反复使用



**设计模式的重要性**

- 提升代码的质量和可维护性
- 加速开发与协作
- 支持系统扩展与灵活性
- 规避常见设计陷进





**设计模式分类**

- 创建型模式

  用于描述如何创建对象，重点是将对象的创建与使用分离。有单例、原型、工厂方法、抽象方法、建造者等5种创建型模式



- 结构性模式

  用于描述如何将类或对象按照某种布局组成更大的结构。有代理、适配器、桥接、装饰、外观、享元、组合等7种结构型模式



- 行为型模式

  用于描述类或对象之间怎样相互协作共同完成某一个对象无法单独完成的任务，以及怎样分配职责。有模版方法、策略、命令、责任链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式





# UML

UML（Unified Modeling Language）：统一建模语言，是一种软件设计的可视化建模语言

从UML衍生出的9种不同图形：类图、对象图、例图、状态图、活动图、时序图、协作图、构件图、部署图



Java的核心就是类，所以下面讲述类图和类与类之间的关系



## 类图

在类图中，一般都是**子类指向父类**，**依赖方指向被依赖方**

**同种类型之间使用实线表示**（类与类、接口与接口），**不同类型之间使用虚线表示**（类与接口）



一个类图示例

<img src = "https://gitee.com/liuyun_wind/image/raw/master/ArrayList.png" align="left" style="zoom:50%;" >







## 类与类之间的关系

**继承关系**

一个类（子类/派生类）继承自另一个类（父类/基类）



**实现关系**

一个类（实现类）实现了一个或多个接口



**关联关系**

两个类之间存在 “一般的联系”，是一种松散的依赖关系，**通常通过成员变量引用实现**



**聚合关系**

关联关系的一种特例，强调 “整体与部分” 的关系，**部分可以脱离整体独立存在**

示例：`Department`（部门）和 `Employee`（员工）：部门包含员工，员工离职后仍可存在（加入其他部门）



**组合关系**

关联关系的另一种特例，同样是 “整体与部分”，但**部分不能脱离整体独立存在**（整体销毁，部分也销毁）

示例：`House`（房子）和 `Room`（房间）：房间不能脱离房子单独存在，房子拆除后，房间也不存在



**依赖关系**

一个类（依赖方）需要另一个类（被依赖方）的协助，通常通过**方法参数**、局部变量或静态方法调用体现



关系强度排序：

**依赖（Dependency）** < **关联（Association）** < **聚合（Aggregation）** < **组合（Composition）** < **继承（Inheritance）**

越弱的关系，类的独立性越强，灵活性越高

越强的关系，耦合度越高，灵活性越低





# 软件设计原则

为了提高软件系统的可维护性、可复用行、可扩展性和灵活性，提出了下面6种软件设计原则



**开闭原则**

> 对扩展开放，对修改闭关



**里氏替换原则**

> 任何基类可以出现的地方，子类也可以出现



**依赖倒转原则**

> 上层模块不应该依赖于底层模块，它们都应该依赖于抽象
>
> 抽象不应该依赖于细节，细节应该依赖于抽象

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互



**接口隔离原则**

> 客户端不应该依赖它不需要的接口
>
> 类间的依赖关系应该建立在最小的接口上

每个接口中不存在子类用不到却必须实现的方法，如果不然，需要将接口拆分。使用多个隔离的接口，比使用单个接口要好



**迪米特法则**

> 只与你的直接朋友交谈，不跟“陌生人”说话



**合成复用原则**

> 尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的





# 创建型模式

对类的实例化过程进行了抽象，能够将软件模块中**对象的创建**和**对象的使用**分离



创建型模式有这5种：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式



## 单例模式

Java中最简单的一个模式，该模式只和单一的类有关（单例类）

单例类只负责创建自己的对象，同时确保只有一个对象被创建



单例模式的结构：

单例类：只创建一个示例的类

访问类：使用单例类



单例模式分为饿汉式和懒汉式

饿汉式：类加载时单例对象就被创建

懒汉式：类加载时不创建对象，在单例对象首次使用时创建



饿汉式单例实现：

~~~java
package com.zms.single.demo1;

public class Singleton {
    // 将构造方法私有化，防止通过构造方法创建新的对象
    private Singleton(){}

    // 声明的同时赋值。实现饿汉式单例
    private static Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
}
~~~





懒汉式单例实现：

~~~java
package com.zms.single.demo2;

public class Singleton {
    private Singleton() {}

    // 只声明，不赋值。实现懒汉式单例
    private static Singleton singleton;

    public static Singleton getInstance() {
        if(singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
~~~



**Java中的单例类：**

Runtime、Logger、数据库连接对象





## 工厂模式



### 简单工厂模式





### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类



结构：

- 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品
- 具体工厂（Concrete Factory）：实现了抽象工厂中的抽象方法，完成具体产品的创建
- 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能
- 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应



优缺点：符合开闭原则。但是**每增加一个产品就要增加一个具体产品类和具体工厂类，增加了系统复杂度**









### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。





结构：

- 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品
- 具体工厂（Concrete Factory）：实现了抽象工厂中的抽象方法，完成具体产品的创建
- 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能
- 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应









## 原型模式

定义：

**用一个已经创建的实例作为原型，通过复刻该原型对象来创建一个和原型对象相同的新对象**



结构：

- 抽象原型类：规定了原型对象必须实现的 clone()方法
- 具体原型类：实现抽象原型类的clone()方法，它是可以被复制的对象
- 访问类：使用具体原型类中的close() 方法来复制新的对象



原型模式的克隆分为浅克隆和深克隆

> 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同
>
> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原来对象地址



在Java中，一个类如果要调用 clone()方法，需要重写 `protected clone()`方法，并且实现` Cloneable`接口，这个克隆方法是浅克隆















## 建造者模式

定义：

**将一个复杂的对象的构建与表示分离**，使得同样的构造过程可以创建不同的结果

产品的构建由Builder负责，装配由Director负责，从而构造出复杂的对象

 

结构：

- 抽象建造者类（Builder）：这个接口规定要实现复杂对象的哪部分创建，并不涉及具体部件对象的创建
- 具体创建者类（Concrete Builder）：实现 Builder接口，完成复杂产品的各个部件的具体创建方法，在构造过程完成后，提供产品的实例
- 产品类（Product）：要创建的复杂对象
- 指挥者类（Director）：调用具体构造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的消息，只负责保证对象各部分完整创建或按照某种顺序创建



建造者模式与工厂模式的区别：

- 工厂方法模式注重整体对象的创建，抽象工厂模式实现对其产品家族的创建；建造者模式注重部件的构建过程



示例：

1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”；

2、Java中的StringBuilder



代码示例：

~~~java
package com.zms.builder.demo2;

// 手机类
public class Phone {
    private String cpu;
    private String memory;
    private String mainBoard;

    // 私有构造方法
    private Phone(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.mainBoard = builder.mainBoard;
    }

    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", memory='" + memory + '\'' +
                ", mainBoard='" + mainBoard + '\'' +
                '}';
    }

    // 静态内部类
    public static final class Builder {
        private String cpu;
        private String memory;
        private String mainBoard;

        public Builder cpu(String cpu) {
            this.cpu = cpu;
            return this;
        }
        public Builder memory(String memory) {
            this.memory = memory;
            return this;
        }
        public Builder mainBoard(String mainBoard) {
            this.mainBoard = mainBoard;
            return this;
        }

        // 使用构建者创建Phone对象
        public Phone build() {
            return new Phone(this);
        }
    }
}
~~~



测试代码

~~~java
package com.zms.builder.demo2;

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainBoard("华硕")
                .memory("金士顿")
                .build();

        System.out.println(phone);
    }
}
~~~







# 结构型模式



**结构型模式描述如何将类或对象按照某种布局组成更大的结构**。它分为类结构模式和对象结构型模式，前者采用继承机制实现，后者采用组合实现

结构型模式分为下面7种：

- 代理模式
- 适配器模式
- 装饰器模式
- 桥接模式
- 外观模式
- 组合模式
- 享元模式



## 代理模式

概述：

由于某些原因需要给目标对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象与目标对象的中介

Java中的代理按照类的生成时机分为静态代理和动态代理。静态代理类在编译器生成，动态代理类在运行时生成，动态代理又分 JDK代理 和CGLIB代理



代理模式结构：

- 抽象主题类（Subject）；通过接口或抽象类声明真实主题和代理对象实现的业务方法
- 真实主题类（Real Subject）：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终被引用的对象（主题也可以称为目标）
- 代理类（Proxy）：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能

<img src="https://gitee.com/liuyun_wind/image/raw/master/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FUML.png" align="left" style="zoom:33%;" >



总结：

- 静态代理就是创建目标类的子类，并重写目标类的方法
- JDK动态代理会在运行时生成目标类的代理对象，执行代理方法 等于 先进行前置增强再执行原方法最后执行后置增强
- CGLIB动态的依赖要看JDK版本，3.3.0以下的只适用于JDK8及以下，因为Java9之后引入了模块化





### 静态代理

静态代理就是创建目标类的子类，在使用的时候使用里氏替换

示例：

明星接口--抽象主题

真实明星--真实主题

经纪人----代理类



明星接口

~~~java
package com.zms.proxy.static_proxy;

public interface Star {
    void signContract(); // 签合同
    void perform();      // 演出
    void collectMoney(); // 收钱
}

~~~



明星类

~~~java
package com.zms.proxy.static_proxy;

public class RealStar implements Star {
    @Override
    public void signContract() {
        System.out.println("明星：合同太复杂，我不看了...");
    }

    @Override
    public void perform() {
        System.out.println("明星：唱跳rap music"); // 核心业务
    }

    @Override
    public void collectMoney() {
        System.out.println("明星：钱太多，数不过来...");
    }
}
~~~



代理类

~~~java
package com.zms.proxy.static_proxy;

public class AgentProxy implements Star {
    private RealStar realStar;

    public AgentProxy(RealStar realStar) {
        this.realStar = realStar;
    }

    @Override
    public void signContract() {
        System.out.println("经纪人：仔细审阅合同条款，确保明星利益！"); // 前置增强
        realStar.signContract(); // 调用明星的方法
    }

    @Override
    public void perform() {
        System.out.println("经纪人：安排行程，对接场地，确保演出顺利！");
        realStar.perform(); // 明星只负责表演
        System.out.println("经纪人：演出结束，安排明星返程！"); // 后置增强
    }

    @Override
    public void collectMoney() {
        realStar.collectMoney(); // 明星收钱
        System.out.println("经纪人：扣除佣金，转账给明星！"); // 后置增强
    }
}

~~~



客户端

~~~java
package com.zms.proxy.static_proxy;

public class Client {
    public static void main(String[] args) {
        // 创建真实明星
        RealStar realStar = new RealStar();

        // 创建明星的代理（经纪人）
        AgentProxy proxy = new AgentProxy(realStar);

        // 客户端只通过代理访问明星
        proxy.signContract();
        proxy.perform();
        proxy.collectMoney();
    }
}
~~~





### JDK动态代理

明星接口

~~~java
package com.zms.proxy.jdk_proxy;

public interface Star {
    void signContract(); // 签合同
    void perform();      // 演出
    void collectMoney(); // 收钱
}

~~~



明星类

~~~java
package com.zms.proxy.jdk_proxy;

public class RealStar implements Star {
    @Override
    public void signContract() {
        System.out.println("明星：合同太复杂，我不看了...");
    }

    @Override
    public void perform() {
        System.out.println("明星：唱跳rap music"); // 核心业务
    }

    @Override
    public void collectMoney() {
        System.out.println("明星：钱太多，数不过来...");
    }
}
~~~



代理对象工厂类

~~~java
package com.zms.proxy.jdk_proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {
    // 目标对象
    private final RealStar realStar = new RealStar();

    // 获取代理对象
    public Star getProxyObject() {
        /**
         * ClassLoader loader：被代理类的类加载器
         * Class<?>[] interfaces：类代理类实现的所有接口
         * InvocationHandler h：调用处理程序，用于将方法调用分派
         */
        Star star = (Star) Proxy.newProxyInstance(
                realStar.getClass().getClassLoader(),
                realStar.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * Object proxy：动态生成的代理类
                     * Method method：被代理类执行的方法
                     * Object[] args：被代理类执行方法的参数
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // 方法调用前的增强逻辑
                        if (method.getName().equals("signContract")) {
                            System.out.println("经纪人：仔细审阅合同条款，确保明星利益！");
                        } else if (method.getName().equals("perform")) {
                            System.out.println("经纪人：安排行程，对接场地，确保演出顺利！");
                        }

                        // 调用真实对象的方法
                        // 第一个参数是真实对象，第二个参数是真实对象方法的参数
                        Object result = method.invoke(realStar, args);

                        // 方法调用后的增强逻辑
                        if (method.getName().equals("perform")) {
                            System.out.println("经纪人：演出结束，安排明星返程！");
                        } else if (method.getName().equals("collectMoney")) {
                            System.out.println("经纪人：扣除佣金，转账给明星！");
                        }

                        return result;
                    }
                }
        );
        return star;
    }
}
~~~





客户端

~~~java
package com.zms.proxy.jdk_proxy;

public class Client {
    public static void main(String[] args) {
        // 获取工厂类
        ProxyFactory agentProxy = new ProxyFactory();
        // 获取代理类
        Star star = agentProxy.getProxyObject();
        // 执行代理方法
        star.perform();
    }
}
~~~







### CGLIB动态代理

明星类

~~~java
package com.zms.proxy.cglib_proxy;

public class RealStar   {

    public void signContract() {
        System.out.println("明星：合同太复杂，我不看了...");
    }


    public void perform() {
        System.out.println("明星：唱跳rap music"); // 核心业务
    }


    public void collectMoney() {
        System.out.println("明星：钱太多，数不过来...");
    }
}
~~~





工厂类

~~~java
package com.zms.proxy.cglib_proxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class ProxyFactory implements MethodInterceptor {

    public RealStar getInstance() {
        // 创建Enhancer对象，相当于JDK代理中的Proxy
        Enhancer enhancer = new Enhancer();
        // 设置父类字节码
        enhancer.setSuperclass(RealStar.class);
        // 设置回调函数
        enhancer.setCallback(this);
        // 创建代理对象
        return (RealStar) enhancer.create();
    }

    /**
     * @param o           代理对象
     * @param method      目标对象的执行方法
     * @param objects     目标对象的执行方法的参数
     * @param methodProxy 方法代理对象，用于调用父类方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        // 方法调用前的增强逻辑
        if (method.getName().equals("signContract")) {
            System.out.println("经纪人：仔细审阅合同条款，确保明星利益！");
        } else if (method.getName().equals("perform")) {
            System.out.println("经纪人：安排行程，对接场地，确保演出顺利！");
        }

        // 调用真实对象的方法
        // 第一个参数是代理对象，第二个参数是真实对象方法的参数，返回值就是目标方法返回值
        Object result = methodProxy.invokeSuper(o, objects);

        // 方法调用后的增强逻辑
        if (method.getName().equals("perform")) {
            System.out.println("经纪人：演出结束，安排明星返程！");
        } else if (method.getName().equals("collectMoney")) {
            System.out.println("经纪人：扣除佣金，转账给明星！");
        }

        return result;
    }
}
~~~





客户端

~~~java
package com.zms.proxy.cglib_proxy;

public class Client {
    public static void main(String[] args) {
        // 获取代理工厂
        ProxyFactory proxyFactory = new ProxyFactory();
        // 获取代理对象（实际上就是RealStar的子类）
        RealStar realStar = proxyFactory.getInstance();
        // 执行代理方法
        realStar.perform();
    }
}
~~~









## 适配器模式

定义：

将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类一起工作



结构：

- 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口
- 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口
- 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者



示例：

计算机只能读取SD卡，现在添加一个适配器，让计算机可以读取TF卡

目标接口

~~~java
package com.zms.adapter.object_adapter;

public interface TFCard {
    // 从TF卡读数据
    String readTF();

    // 向TF卡写数据
    void writeTF(String tf);
}
~~~



原接口

~~~java
package com.zms.adapter.object_adapter;

// 目标接口
public interface SDCard {

    // 从SD卡读数据
    String readSDCard();

    // 向SDCard卡写数据
    void writeSDCard(String sdCard);
}
~~~



适配者类

~~~java
package com.zms.adapter.object_adapter;

public class TFCardImpl implements TFCard {
    @Override
    public String readTF() {
        String msg = "TFCard message: hello TFCard";    // 演示数据
        return msg;
    }

    @Override
    public void writeTF(String tf) {
        System.out.println(tf);         // 将数据输出到控制台，模拟输出到TFCard
    }
}

/**********/

package com.zms.adapter.object_adapter;

public class SDCardImpl implements SDCard {
    @Override
    public String readSDCard() {
        String msg = "SDCard message: hello SDCard";
        return msg;
    }

    @Override
    public void writeSDCard(String sdCard) {
        System.out.println(sdCard);
    }
}
~~~



适配器类

~~~java
package com.zms.adapter.object_adapter;

import com.zms.adapter.class_adapter.TFCard;

// 适配器类
public class SDAdapter  implements SDCard {
    private TFCard tfCard;

    public SDAdapter(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    @Override
    public String readSDCard() {
        System.out.println("adapter read tf card");
        return tfCard.readTF();
    }

    @Override
    public void writeSDCard(String sdCard) {
        System.out.println("adapter write tf card");
        tfCard.writeTF(sdCard);
    }
}
~~~



计算机类

~~~java
package com.zms.adapter.object_adapter;

public class Computer {

    // 计算机读取SD卡
    public String readSD(SDCard sdCard) {
        if(sdCard == null) {
            throw new NullPointerException("SDCard is null");
        }
        return sdCard.readSDCard();
    }
}
~~~



客户端

~~~java
package com.zms.adapter.object_adapter;

import com.zms.adapter.class_adapter.TFCardImpl;

public class Client {
    public static void main(String[] args) {
        // 读取SDCard
        Computer computer = new Computer();
        String string = computer.readSD(new SDCardImpl());
        System.out.println(string);

        // 使用计算机读取TFCard
        // 适配器类是SDCard的子类，其成员又有TFCard
        // 计算机读取sd卡数据调用SDCard.readSDCard()，所以调用Adapter.readSDCard()，最终读取TF卡
        SDAdapter sdAdapter = new SDAdapter(new TFCardImpl());
        String string1 = computer.readSD(sdAdapter);
        System.out.println(string1);
    }
}
~~~





## 装饰者模式



定义：

指在不改变现有对象结构的情况下，动态地给对象增加一些职能（即增肌其额外功能）的模式



结构：

- 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象
- 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职能
- 抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过为其子类扩展具体构件的功能
- 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任



优点：

装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能



示例：

FastFood为抽象构件，FireRice、FireNoodle为具体构件，Garnish为抽象装饰器，WithEgg为具体装饰器

继承关系：WithEgg -->  Garnish  -->  FastFood

WithEgg类将快餐快餐信息存储在抽象类Garnish中的成员变量fasFood，而鸡蛋信息存储在基类FastFood中的成员变量price和desc

抽象构件

~~~java
package com.zms.decorator;

// 抽象构件
public abstract class FastFood {
    // 快餐价格
    private int price;
    // 快餐描述
    private String desc;

    public FastFood() {
    }

    public FastFood(int price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    // 快餐价格计算，由子类实现
    public abstract int cost();
}

~~~



真实构件

~~~java
package com.zms.decorator;

// 具体构件
public class FireNoodle extends FastFood{

    public FireNoodle() {
        super(12, "炒面");
    }

    @Override
    public int cost() {
        return getPrice();
    }
}

/************************/

package com.zms.decorator;

// 具体构件
public class FireRice extends FastFood{

    public FireRice() {
        super(10, "炒饭");
    }

    @Override
    public int cost() {
        return getPrice();
    }
}

~~~



抽象装饰器

~~~java
package com.zms.decorator;

// 抽象装饰器类
public abstract class Garnish extends FastFood{

    // 声明快餐中的变量
    private FastFood fastfood;

    public FastFood getFastfood() {
        return fastfood;
    }

    public void setFastfood(FastFood fastfood) {
        this.fastfood = fastfood;
    }

    public Garnish(FastFood fastfood, int price, String desc) {
        super(price, desc);
        this.fastfood = fastfood;
    }
}
~~~



具体装饰者

~~~java
package com.zms.decorator;

// 具体装饰
public class WithEgg extends Garnish {
    public WithEgg(FastFood fastfood) {
        super(fastfood, 1, "鸡蛋");
    }

    // WithEgg -->  Garnish  -->  FastFood
    // 快餐的信息存储在抽象类Garnish中的成员变量Fastfood，鸡蛋信息存储在基类FastFood中的成员price和desc
    // getPrice()返回的是鸡蛋的价格，getFastfood().cost()返回的是快餐的价格
    @Override
    public int cost() {
        return getPrice() + getFastfood().cost();
    }
}

~~~



客户端

~~~java
package com.zms.decorator;

public class Client {
    public static void main(String[] args) {
        // 一份炒饭
        FastFood fireRice = new FireRice();
        System.out.println(fireRice.getDesc() + " " + fireRice.getPrice() + "元");

        // 在炒饭上面加一个鸡蛋
        WithEgg food = new WithEgg(fireRice);
        System.out.println(food.getDesc() + " " + food.cost() + "元");

        // 再加一个鸡蛋
        WithEgg with2Egg = new WithEgg(food);
        System.out.println(with2Egg.getDesc() + " " + with2Egg.cost());
    }
}
~~~





## 桥接者模式

定义：

将抽象与实现分离，使它们可以独立变化。它使用组合关系替代继承关系，从而降低了抽象和实现这两个可变维度的耦合度



结构：

- 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用
- 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法
- 实现化（Implmentor）角色：定义实现化角色的接口，供扩展抽象化角色调用
- 具体实现化（Concrete Implmentor）：给出实现化角色接口的具体实现



优点：任意修改一个维度不会影响另一个维度



示例：

一个视频播放器案例，有两个方面要考虑，操作系统和视频格式

<img src = "https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_18-25-58.png" align="left">



抽象化角色

~~~java
package com.zms.bridge;

// 视频文件格式
public interface VideoFile {

    // 解码功能
    void decode(String fileName);
}
~~~



扩展抽象化角色

~~~java
package com.zms.bridge;

// 抽象操作系统
public abstract class OperatingSystem {

    // VideoFile变量
    protected VideoFile videoFile;

    public OperatingSystem(VideoFile videoFile) {
        this.videoFile = videoFile;
    }

    public abstract void play(String fileName);
}
~~~



实现化角色

~~~java
package com.zms.bridge;

// avi视频文件
public class AviFile implements VideoFile{
    @Override
    public void decode(String fileName) {
        System.out.println("avi 视频文件：" + fileName);
    }
}

/*************/
package com.zms.bridge;

// Rmvb视频文件
public class RmvbFile implements VideoFile{
    @Override
    public void decode(String fileName) {
        System.out.println("Rmbv 视频文件：" + fileName);
    }
}
~~~



具体实现化

~~~java
package com.zms.bridge;

public class Windows extends OperatingSystem{
    public Windows(VideoFile videoFile) {
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}
/************************************/
package com.zms.bridge;


public class Mac extends OperatingSystem{
    public Mac(VideoFile videoFile) {
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}
~~~



客户端

~~~java
package com.zms.bridge;

public class Client {
    public static void main(String[] args) {
        OperatingSystem system = new Mac(new AviFile());
        system.play("战狼2");
    }
}
~~~



















## 外观模式

定义：

又名“门面模式”，是一种为多个复杂的子系统提供一个一致的接口，而使这些子系统更容易被访问的模式

外观模式是“迪米特法则”的典型应用



结构：

- 外观（Facade）角色：为多个子系统对外提供统一的共同的接口
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它



优缺点：

- 降低子系统与客户端的耦合度，对客户屏蔽了子系统组件，让子系统使用更加方便
- 不符合开闭原则，修改很麻烦



示例：



<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_18-37-13.png" align="left">





子系统角色

~~~java
package com.zms.facade;

// 空调
public class AirCondition {

    // 打开空调
    public void on() {
        System.out.println("打开空调...");
    }

    // 关闭空调
    public void off() {
        System.out.println("关闭空调...");
    }
}
/***************/
package com.zms.facade;

// 电灯
public class Light {

    // 打开电灯
    public void on() {
        System.out.println("打开电灯...");
    }

    // 关闭电灯
    public void off() {
        System.out.println("关闭电灯...");
    }
}
/**************/
package com.zms.facade;

// 电视机
public class TV {

    // 打开电视机
    public void on() {
        System.out.println("打开电视机...");
    }

    // 关闭电视机
    public void off() {
        System.out.println("关闭电视机...");
    }
}
/*********************/
~~~



外观角色

~~~java
package com.zms.facade;

public class SmartApplicationFacade {
    private TV tv;
    private AirCondition airCondition;
    private Light light;

    public SmartApplicationFacade() {
        tv = new TV();
        airCondition = new AirCondition();
        light = new Light();
    }

    // 语音控制
    public void say(String message) {
        if(message.contains("打开")) {
            on();
        } else if (message.contains("关闭")) {
            off();
        } else {
            System.out.println("我还听不懂你说的话呢");
        }
    }

    private void on() {
        tv.on();
        airCondition.on();
        light.on();
    }
    private void off() {
        tv.off();
        airCondition.off();
        light.off();
    }
}
~~~



客户端

~~~java
package com.zms.facade;

public class Client {
    public static void main(String[] args) {
        SmartApplicationFacade facade = new SmartApplicationFacade();
        facade.say("打开家电");
        System.out.println("---------------------");
        facade.say("关闭家电");
    }
}
~~~







## 组合模式

定义：

组合模式又名整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的**树形结构**



结构：

- 抽象根节点（Component）：定义系统个层次对象的共有方法和属性，可以预先定义一些默认行为和属性
- 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构
- 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位



示例：

模拟文件系统管理

树枝节点就是文件夹、叶子节点就是文件，它们都是抽象根节点的子类

抽象根节点

~~~java
package com.zns.combination;

// 菜单组件：抽象根节点
public abstract class MenuComponent {

    // 菜单组件的名称
    protected String name;

    // 菜单组件的层级
    protected int level;

    // 添加子菜单
    public void add(MenuComponent component) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    // 移除子菜单
    public void remove(MenuComponent component) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    // 获取指定子菜单
    public MenuComponent getChild(int index) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    // 获取菜单或者菜单项的名称
    public String getName() {
        return name;
    }

    // 打印菜单名称的方法（包含菜单和子菜单项）
    public abstract void print();
}
~~~





树枝节点

~~~java
package com.zms.combination;

import java.util.ArrayList;
import java.util.List;

// 菜单类：树枝节点
public class Menu extends MenuComponent {
    // 菜单可以有多个菜单或者菜单项
    private List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();

    public Menu(String name, int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void add(MenuComponent component) {
        menuComponents.add(component);
    }

    @Override
    public void remove(MenuComponent component) {
        menuComponents.remove(component);
    }

    @Override
    public MenuComponent getChild(int index) {
        return menuComponents.get(index);
    }

    @Override
    public void print() {
        for(int i = 0; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
        for (MenuComponent menuComponent : menuComponents) {
            menuComponent.print();
        }
    }
}
~~~



菜单项

~~~java
package com.zms.combination;

// 菜单项
public class MenuItem extends MenuComponent {
    public MenuItem(String name, int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void print() {
        for(int i = 0; i < level; i++) {
            System.out.print("--");
        }
        // 打印菜单项名称
        System.out.println(name);
    }
}
~~~



客户端

~~~java
package com.zms.combination;

public class Client {
    public static void main(String[] args) {
        // 二级菜单和菜单项
        Menu menu1 = new Menu("菜单管理", 2);
        menu1.add(new MenuItem("页面访问", 3));
        menu1.add(new MenuItem("展示菜单", 3));
        menu1.add(new MenuItem("编辑菜单", 3));
        menu1.add(new MenuItem("删除菜单", 3));
        menu1.add(new MenuItem("新增菜单", 3));

        Menu menu2 = new Menu("权限配置", 2);
        menu2.add(new MenuItem("页面访问", 3));
        menu2.add(new MenuItem("提交保存", 3));

        Menu menu3 = new Menu("角色管理", 2);
        menu3.add(new MenuItem("页面访问", 3));
        menu3.add(new MenuItem("修改角色", 3));

        // 创建一级菜单
        // 将二级菜单添加到一级菜单
        Menu menu = new Menu("系统管理", 1);
        menu.add(menu1);
        menu.add(menu2);
        menu.add(menu3);

        // 打印系统菜单
        menu.print();
    }
}
~~~





## 享元模式



定义：

运用共享技术来有效支持大量细颗粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量，避免大量的相似对象的开销，从而提高系统资源的利用率



享元模式存在的两种状态：

1. 内部状态：不随环境的改变而改变的可共享部分
2. 外部状态：指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化



享元模式的角色：

- 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类的公共方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）
- 具体享元（Concrete Flyweight）角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象
- 非享元（Unsharable Flyweight）角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可以设计为非共享具体享元类；当需要一个非共享享元类的对象时可以直接通过实例化创建
- 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色，当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在，则创建一个新的享元对象



优缺点：

- 减少了内存中相似或相同对象的数量，节约资源
- 享元模式中的外部状态相对独立，且不影响内部状态





示例：

<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_21-37-42.png" >





抽象享元角色：

~~~java
package com.zms.flyweight;

// 抽象享元角色
public abstract class AbstractBox {

    // 获取图形
    public abstract String getShape();

    // 显示图形及颜色
    public void display(String color) {
        System.out.println("方块形状：" + getShape() + ", 方块颜色：" + color);
    }
}
~~~



工厂类

~~~java
package com.zms.flyweight;

import java.util.HashMap;

// 工厂类
public class BoxFactory {

    private final HashMap<String, AbstractBox> map;

    public BoxFactory() {
        map = new HashMap<>();
        map.put("I", new IBox());
        map.put("O", new OBox());
        map.put("L", new LBox());
    }

    // 根据名称获取对象
    public AbstractBox getBox(String type) {
        return map.get(type);
    }

    public static BoxFactory getFactory() {
        return factory;
    }
    private static final BoxFactory factory = new BoxFactory();
}
~~~



具体享元角色

~~~java
package com.zms.flyweight;

public class OBox extends AbstractBox{
    @Override
    public String getShape() {
        return "O";
    }
}
/**************************/
package com.zms.flyweight;

public class IBox extends AbstractBox{
    @Override
    public String getShape() {
        return "I";
    }
}
/****************************/
package com.zms.flyweight;

public class LBox extends AbstractBox{
    @Override
    public String getShape() {
        return "L";
    }
}
~~~

















# 行为型模式



**行为型模式主要用于描述程序在运行时复杂的流程控制**

行为型模式主要分为类行为模式和对象行为模式，类行为模式主要通过继承机制实现类间分派行为，对象行为模式主要通过组合在对象间分派行为

- 类行为模式：
  - 模版方法模式
  - 解释器模式
- 对象行为模式：
  - 策略模式
  - 命令模式
  - 职责链模式
  - 状态模式
  - 观察者模式
  - 中介者模式
  - 迭代器模式
  - 访问者模式
  - 备忘录模式



## 模版方法模式

模版方法模式：

它在一个抽象类中定义了一个算法的骨架，而将一些步骤延迟到子类中实现，使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。



结构：

- 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模版方法和若干个基本方法组成
  - 模版方法：定义了算法的骨架，按照某种顺序调用其包含的基本方法
  - 具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承
    - 抽象方法（Abstract Method）：一个抽象方法由抽象声明、由其具体子类实现
    - 具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承
    - 钩子方法（Hook Method）：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXXX，返回值类型为 boolean类型
- 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子函数，它们是一个顶级逻辑的组成步骤



优缺点：

- 优点：**将相同的代码放在抽象类，而将不同的代码放在子类**，提高代码的复用性。通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现反向控制，符合“开闭原则”。这是非常常用的设计模式，最能充分利用继承中方法重写的特性
- 缺点：**不容易找到方法实现，代码可读性稍低**



示例：

<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_22-01-01.png" align="left">



抽象类

~~~java
package com.zms.template;

// 抽象类
public abstract class AbstractClass {

    // 模版方法定义
    public final void process() {
        pourOil();
        heatOil();
        pourVegetable();
        pourSauce();
        fry();
    }

    // 倒油
    public void pourOil() {
        System.out.println("倒油");
    }

    // 热油
    public void heatOil() {
        System.out.println("热油");
    }

    // 倒蔬菜
    public abstract void pourVegetable();

    // 倒调料
    public abstract void pourSauce();

    // 翻炒，都是一样，所以不需要抽象
    public void fry() {
        System.out.println("炒啊炒");
    }
}
~~~



具体子类

~~~java
package com.zms.template;

// 具体子类
public class ConcreteClass_CaiXin extends AbstractClass {
    @Override
    public void pourVegetable() {
        System.out.println("下锅的是菜心");
    }

    @Override
    public void pourSauce() {
        System.out.println("下锅的酱料是蒜蓉");
    }
}
/******************************/
package com.zms.template;

// 具体子类
public class ConcreteClass_BaoCai extends AbstractClass {
    @Override
    public void pourVegetable() {
        System.out.println("下锅的是包菜");
    }

    @Override
    public void pourSauce() {
        System.out.println("下锅的酱料是香葱");
    }
}
~~~



客户端

~~~java
package com.zms.template;

public class Client {
    public static void main(String[] args) {
        // 炒包菜
        ConcreteClass_BaoCai concreteClassBaoCai = new ConcreteClass_BaoCai();
        // 调用整个炒菜算法
        concreteClassBaoCai.process();
    }
}
~~~





## 策略模式



策略模式：

该模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的视线分隔开，并委派给不同的对象进行管理 





策略模式的主要角色：

- 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色需要给出所有的具体策略类所需的接口
- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为
- 环境（Context）类：持有一个策略类的引用，最终给客户端调用



**示例：**

根据不同节假日，选择不同促销活动

有如下不同的Java类

<img src="C:/Users/zms/AppData/Roaming/Typora/typora-user-images/image-20250716143037611.png" alt="image-20250716143037611" style="zoom:80%;" align="left"/>





策略类接口

~~~java
package com.zms.strategy;


// Description: 策略类接口
public interface Strategy {
    void activity();
}
~~~



具体策略类

~~~java
package com.zms.strategy;

// 具体策略类A
public class StrategyA implements Strategy {
    public void activity() {
        System.out.println("买一送一");
    }
}

/**********/
package com.zms.strategy;

// 具体策略类B
public class StrategyB implements Strategy {
    public void activity() {
        System.out.println("满100减20");
    }
}

/**********/
package com.zms.strategy;

// 具体策略类C
public class StrategyC implements Strategy {
    public void activity() {
        System.out.println("清仓甩卖，全场8折");
    }
}
~~~





环境类

~~~java
package com.zms.strategy;

// 环境类，售货员
public class SaleMan {
    // 聚合策略
    private Strategy strategy;

    public SaleMan(Strategy strategy) {
        this.strategy = strategy;
    }

    public void sale() {
        // 售货员展示促销活动
        strategy.activity();
    }
}
~~~



客户端

~~~java
package com.zms.strategy;

// 客户端
public class Client {
    public static void main(String[] args) {
        // 春节，春节促销活动
        SaleMan saleMan = new SaleMan(new StrategyA());
        saleMan.sale();

        // 中秋节，中秋节促销活动
        SaleMan saleMan1 = new SaleMan(new StrategyB());
        saleMan1.sale();
    }
}
~~~















## 命令模式

命令模式：

将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理



命令模式包含的角色：

- 抽象命令类（Command）角色：定义命令的接口，声明执行的方法
- 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接受者，并调用接受者的功能来完成命令要执行的操作
- 实现者/接受者（Receiver）角色：接受者，真正执行命令的对象，任何类都可以成为一个接受者，只要它可以实现命令要求实现的功能
- 调用者/请求者（Invoker）角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象，这个是客户端真正触发命令并要求执行相应的操作，也就是说相当于命令对象的入口



示例：

<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_22-48-41.png" align="left">



抽象命令类

~~~java
package com.zms.command;

// 抽象命令类
public interface Command {
    void excute();
}
~~~



具体命令类

~~~java
package com.zms.command;

import java.util.Map;

// 具体命令类
public class OrderCommand implements Command {

    // 持有接受者对象
    private Chef chef;
    private Order order;

    public OrderCommand(Chef chef, Order order) {
        this.chef = chef;
        this.order = order;
    }

    @Override
    public void excute() {
        System.out.println(order.getDiningTable() + "桌的订单开始制作");
        Map<String, Integer> foodDir = order.getFoodDir();
        for (String foodName : foodDir.keySet()) {
            chef.makeFood(foodName, foodDir.get(foodName));
        }
        System.out.println(order.getDiningTable() + "桌的订单制作完毕！！！");
    }
}
~~~



订单类

~~~java
package com.zms.command;

import java.util.HashMap;
import java.util.Map;

// 订单类
public class Order {
    // 餐桌号码
    private int diningTable;

    // 菜品和份数
    private Map<String, Integer> foodDir = new HashMap<String, Integer>();

    public int getDiningTable() {
        return diningTable;
    }

    public void setDiningTable(int diningTable) {
        this.diningTable = diningTable;
    }

    public Map<String, Integer> getFoodDir() {
        return foodDir;
    }

    public void setFoodDir(String food, int num) {
        foodDir.put(food, num);
    }
}
~~~



接受者

~~~java
package com.zms.command;

// 厨师类
public class Chef {
    // 制作食物的方法
    public void makeFood(String food, int num) {
        System.out.println("制作了 " + num + " 份 " + food);
    }
}
~~~



请求者

~~~java
package com.zms.command;

import java.util.ArrayList;
import java.util.List;

// 服务员类
public class Waitor {

    // 持有多个命令对象
    private List<Command> commandList = new ArrayList<Command>();

    // 将cmd对象存储到集合
    public void addCommand(Command command) {
        commandList.add(command);
    }

    // 服务员发起命令
    public void orderUp() {
        System.out.println("厨师，来活了");
        // 遍历集合
        for (Command command : commandList) {
            if (command != null) {
                command.excute();
            }
        }
    }
}
~~~



客户端

~~~java
package com.zms.command;

public class Client {
    public static void main(String[] args) {
        // 创建订单对象
        Order order = new Order();
        order.setDiningTable(2);
        order.setFoodDir("炒鱿鱼", 1);
        order.setFoodDir("宫保鸡丁", 2);

        // 第二个订单
        Order order1 = new Order();
        order1.setDiningTable(3);
        order1.setFoodDir("西红柿炒鸡蛋", 1);

        // 厨师
        Chef chef = new Chef();

        // 命令对象
        OrderCommand orderCommand = new OrderCommand(chef, order);
        OrderCommand orderCommand1 = new OrderCommand(chef, order1);

        // 服务员
        Waitor waitor = new Waitor();
        waitor.addCommand(orderCommand);
        waitor.addCommand(orderCommand1);

        // 调用
        waitor.orderUp();
    }
}
~~~





## 责任链模式



责任链模式：

为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止



责任链模式主要的角色：

- 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接
- 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，否则将请求转发给他的后继者
- 客户（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它并不关心处理请求和请求的传递过程









示例：

<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-18_23-13-00.png">

抽象处理者

~~~java
package com.zms.responsibility;

// 抽象处理类
public abstract class Handler {
    protected final static int NUM_ONE = 1;
    protected final static int NUM_THREE = 3;
    protected final static int NUM_SEVEN = 7;

    // 领导处理的请假请求天数
    private int numStart;
    private int numEnd;

    // 后继者（上级领导）
    private Handler nextHandler;

    public Handler(int numStart) {
        this.numStart = numStart;
    }

    public Handler(int numStart, int numEnd) {
        this.numStart = numStart;
        this.numEnd = numEnd;
    }

    // 设置上级领导对象
    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    // 各级领导处理请假条的方法
    protected abstract void handle(LeaveRequest leaveRequest);

    // 提交请假条
    public final void submit(LeaveRequest leaveRequest) {
        // 判断当前处理者是否有权限处理（天数在 [numStart, numEnd] 范围内）
        if (leaveRequest.getNum() >= numStart && leaveRequest.getNum() <= numEnd) {
            this.handle(leaveRequest); // 有权限则处理
            System.out.println("流程结束");
        } else if (this.nextHandler != null) {
            // 无权限则传递给下一级处理者
            this.nextHandler.submit(leaveRequest);
        } else {
            // 没有更高级别处理者，审批不通过
            System.out.println("请假天数超出最大权限，审批不通过");
        }
    }
}
~~~



请假条类

~~~java
package com.zms.responsibility;

// 请假条类
public class LeaveRequest {
    // 请假者姓名
    private String name;
    // 请假天数
    private int num;
    // 请假理由
    private String reason;

    public LeaveRequest(String name, int num, String reason) {
        this.name = name;
        this.num = num;
        this.reason = reason;
    }

    public String getName() {
        return name;
    }

    public int getNum() {
        return num;
    }

    public String getReason() {
        return reason;
    }
}
~~~





具体处理者

~~~java
package com.zms.responsibility;

// 小组长类
public class GroupLeader extends Handler{
    public GroupLeader() {
        super(0, Handler.NUM_ONE);
    }

    @Override
    protected void handle(LeaveRequest leaveRequest) {
        System.out.println(leaveRequest.getName() + "请假" + leaveRequest.getNum() + "， 理由：" + leaveRequest.getReason());
        System.out.println("小组长审批：同意");
    }
}
/****************/
package com.zms.responsibility;

// 部门经理类
public class Manager extends Handler{
    public Manager() {
        super(Handler.NUM_ONE, Handler.NUM_THREE);
    }

    @Override
    protected void handle(LeaveRequest leaveRequest) {
        System.out.println(leaveRequest.getName() + "请假" + leaveRequest.getNum() + "， 理由：" + leaveRequest.getReason());
        System.out.println("部门经理审核：同意");
    }
}
/********************/
package com.zms.responsibility;

// 部门经理类
public class GeneralManager extends Handler{
    public GeneralManager() {
        super(Handler.NUM_THREE, Handler.NUM_SEVEN);
    }

    @Override
    protected void handle(LeaveRequest leaveRequest) {
        System.out.println(leaveRequest.getName() + "请假" + leaveRequest.getNum() + "， 理由：" + leaveRequest.getReason());
        System.out.println("总经理审核：同意");
    }
}
~~~



客户端

~~~java
package com.zms.responsibility;

public class Client {
    public static void main(String[] args) {
        // 创建一个请假条对象
        LeaveRequest request = new LeaveRequest("小明", 9, "身体不适");

        // 创建各级领导
        GeneralManager generalManager = new GeneralManager();
        Manager manager = new Manager();
        GroupLeader groupLeader = new GroupLeader();

        // 设置处理者链
        groupLeader.setNextHandler(manager);
        manager.setNextHandler(generalManager);

        // 小明提交请求
        groupLeader.submit(request);
    }
}
~~~





## 状态模式

状态模式：

在有状态的对象，把复杂的“逻辑判断”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时修改其行为



状态模式结构：

- 环境（Context）角色：上下文，它定义了客户端程序需要的接口，维护一个当前状态，并将状态相关的操作委托给前状态对象来处理
- 抽象状态（State）角色：定义一个接口，用于封装环境对象中特定状态所对应的行为
- 具体状态（Concrete State）角色：实现抽象状态所对应的行为





## 观察者模式

观察者模式：

又称**发布-订阅模式**，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态改变时，会通知所有观察者，使他们能够自动更新自己



观察者模式结构：

- Subject：抽象主题（抽象被观察者），抽象主题把所有观察者对象存入一个集合中，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以添加或删除观察者对象
- ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知
- Observe：抽象观察者（抽象观察者），它定义了一个更新接口，使得主题更改时通知更新自己
- ConcreteObserve：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改时通知更新自身状态



示例：

<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-19_00-07-23.png">



抽象主题：

~~~java
package com.zms.observer;

// 抽象主题
public interface Subject {
    // 添加订阅者（添加观察者）
    void attach(Observer observer);

    // 删除订阅者
    void detach(Observer observer);

    // 通知订阅者更新消息
    void notifyObservers(String message);
}
~~~



真实主题

~~~java
package com.zms.observer;

import java.util.ArrayList;
import java.util.List;

// 具体主题类
public class SubscriptionSubject implements Subject{
    // 存储观察者的集合
    private List<Observer> observers = new ArrayList<Observer>();

    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String message) {
        // 遍历集合
        for (Observer observer : observers) {
            // 调用观察者中的update方法
            observer.update(message);
        }
    }
}
~~~



抽象观察者

~~~java
package com.zms.observer;

// 抽象观察者
public interface Observer {
    public void update(String message);
}
~~~



真实观察者

~~~java
package com.zms.observer;

// 具体的观察者类
public class WeiXinUser implements Observer {
    private String name;
    public WeiXinUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + "-" + message);
    }
}
~~~



客户端

~~~java
package com.zms.observer;

public class Client {
    public static void main(String[] args) {
        // 创建公众号类
        SubscriptionSubject subject = new SubscriptionSubject();

        // 订阅公众号
        subject.attach(new WeiXinUser("小明"));
        subject.attach(new WeiXinUser("小李"));
        subject.attach(new WeiXinUser("小三"));

        // 公众号更新
        subject.notifyObservers("出新文章了！！！");
    }
}
~~~





## 中介者模式

定义：

又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变它们



结构：

- 抽象中介者：中介者接口，提供了同事对象注册与转发同事对象信息的抽象方法
- 具体中介者：抽象中介者子类，定义集合来管理同事，协调同事之间的交互关系，因此它依赖于同事角色
- 抽象同事者：同事类接口，保存中介者对象，提供同时对象的交互方法，实现所有相互影响的同事类的公共功能
- 具体同事类：同事类接口的视线，当需要和其他同事交互时，由中介者对象交互后续的交互



<img src="https://gitee.com/liuyun_wind/image/raw/master/Snipaste_2025-07-17_00-38-24.png" align="left">

优缺点：

- 优点：松散耦合、集中控制交互、一对多关联转变为一对一关联
- 缺点：当同事类太多时，中介者的职责将很大，变得复杂而庞大，导致系统难于维护







## 迭代器模式



定义：

提供一个对象来顺序访问聚合对象中的一些列数据，而不是暴露聚合对象的内部表示



结构：

- 抽象聚合角色：定义存储、添加、删除元素以及创建迭代器对象的接口
- 具体聚合角色：实现抽象聚合类，可以返回一个具体迭代器的实例
- 抽象迭代器角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法
- 具体迭代器角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置





示例：

这里设计一个学生类、聚合学生类，学生迭代器对象

学生类

~~~java
package com.zms.iterator;

// 学生类
public class Student {
    // 学生姓名
    private String name;
    // 学生学号
    private int number;

    public Student(String name, int number) {
        this.name = name;
        this.number = number;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", number=" + number +
                '}';
    }
}
~~~



聚合类

~~~java
package com.zms.iterator;

// 抽象聚合类
public interface StudentAggregate {

    // 添加学生功能
    void add(Student student);

    // 删除学生功能
    void remove(Student student);

    // 返回迭代器
    StudentIterator getStudentIterator();
}
/*****************/

package com.zms.iterator;

import java.util.ArrayList;
import java.util.List;

// 抽象聚合实现类
public class StudentAggregateImpl implements StudentAggregate {
    private List<Student> students = new ArrayList<Student>();

    public StudentAggregateImpl() {
    }

    @Override
    public void add(Student student) {
        students.add(student);
    }

    @Override
    public void remove(Student student) {
        students.remove(student);
    }

    @Override
    public StudentIterator getStudentIterator() {
        return new StudentIteratorImpl(students);
    }
}
~~~



迭代器对象

~~~java
package com.zms.iterator;

public interface StudentIterator {

    // 判断是否还有元素
    boolean hasNext();

    // 返回下一个元素
    Student next();
}
/*********/

package com.zms.iterator;

import java.util.List;

public class StudentIteratorImpl implements StudentIterator{
    private List<Student> studentList;
    private int position = 0;


    public StudentIteratorImpl(List<Student> studentList) {
        this.studentList = studentList;
    }

    @Override
    public boolean hasNext() {
        return position < studentList.size();
    }

    @Override
    public Student next() {
        Student student = studentList.get(position);
        position++;
        return student;
    }
}
~~~



测试用例Client

~~~java
package com.zms.iterator;

// 演示聚合对象和迭代器对象
public class Client {
    public static void main(String[] args) {
        // 聚合对象，这里的集合对象就相当于集合对象
        StudentAggregate studentAggregate = new StudentAggregateImpl();
        studentAggregate.add(new Student("laozhan", 1));
        studentAggregate.add(new Student("laoda", 2));
        studentAggregate.add(new Student("laoxiang", 3));

        // 获取迭代器对象
        StudentIterator studentIterator = studentAggregate.getStudentIterator();
        while (studentIterator.hasNext()) {
            Student student = studentIterator.next();
            System.out.println(student);
        }
    }
}
~~~



## 访问者模式



定义：

封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构前提下定义作用于这些元素的新的操作



结构：

- 抽象访问者（Vistor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，他的方法个数理论上来说和元素个数相同，所以访问者模式要求元素个数不能变
- 具体访问者（ConcreteVistor）角色：给出对每一个元素访问时所产生的具体行为
- 抽象元素（ConcreteElement）角色：提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素的方法
- 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表达，具体可以理解为一个具有容器性质或复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，宫访问者访问





## 备忘录模式

定义：又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后需要时能将该对象恢复到原先的状态



结构：

- 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息
- 备忘录（Memento）角色：对备忘录进行管理，在需要的时候提供这些内部状态给发起人
- 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能但不能对备忘录的内容进行访问与修改









## 解释器模式

定义：

它定义了一种语言的语法表示，并创建一个解释器来解释该语言中的句子。这种模式常用于 SQL 解析、符号处理引擎、编译程序、规则引擎等场景，将复杂的语法规则拆分到各个解释器类中，使得语法的扩展和维护更加方便。





结构：

- 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()
- 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中的于终结符有关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应
- 非终结表达式（Notterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应一个非终结符表达式
- 环境（Context）角色：通常包含各个解释器都需要的数据或是公共给的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值
- 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过角色间接访问解释器的解释方法























# 自定义 Spring框架





## Spring回顾



## Spring核心功能



## Spring IOC相关接口分析



## 自定义SpringIOC



### 定义bean相关的pojo类



### 定义注册表相关类



### 定义解析器相关类



### IOC容器相关类



###自定义Spring IOC总结

**概念：**

- Bean容器：Map<String, Object> singletonObjects。是 AbstractApplicationContext类的属性，所以 Bean容器的初始化由 AbstractApplicationContext 和 它的子类（ClassPathXmlApplicationContext）完成

- BeanDefinition容器：Map<String, BeanDefinition> beanDefinitionMap。是 SimpleBeanDefinitionRegistry类的属性，所以 BeanDefinition容器的初始化由注入了 SimpleBeanDefinitionRegistry类的 XMLBeanDefinitionReader类完成



**容器初始化步骤：**

1. 调用 Spring容器构造函数，进入 ClassPathXmlApplicationContext类

2. 执行构造方法，创建解析器对象，这个解析器对象内部有注册表对象，注册表对象内部维护BeanDefinition容器
3. 调用（子类的AbstractApplicationContext） refresh方法，进入AbstractApplicationContext类，再调用（子类的XMLBeanDefinitionReader）loadBeanDefinitions方法，**加载所有的BeanDefinition**，这里面会用到dom4j工具类的API
4. 调用 finishBeanInitialization方法，这个方法会先获取所有BeanDefinition的name属性，然后调用子类的（ClassPathXmlApplicationContext）的 getBean方法**初始化所有的Bean**，这里会涉及到依赖注入，主要分引用类型依赖和字符串类型依赖
5. refresh方法 完成后，就已经实现了自动装配和依赖注入 
6. 从 Bean容器获取 UserService 对象（实际返回UserServiceImpl），直接使用即可





























